[
    "Turing Game",
    "Rock Paper Scissors",
    "Palindrome",
    "Tic Tac Toe",
    "Chess",
    "Maze",
    "Battlefield",
    "Sudoku",
    "Math",
    "Traveller",
    "Universal Turing Machine",
    "State",
    "Symbol",
    "Next State",
    "Next Symbol",
    "Move",
    "Initial State:",
    "No instructions found",
    "Each instruction must be written on a new line, and must consist of five elements seperated by spaces",
    "Initial state was not found",
    "Move symbol can only take values U (up), D (down), L (left), R (right) and N (none)",
    "State names must not exceed 10 character length",
    "Symbols on the field must not exceed 1 character length",
    "Accepting state was not found",
    "Can not load tests, instructions contain errors",
    "Start tests",
    "Pause tests",
    "Resume tests",
    "Reset tests",
    "Running all the tests...",
    "Tests passed:",
    "Tests failed:",
    "Test",
    "Next",
    "Reset",
    "Current state",
    "Next instruction",
    "Result",
    "Expected",
    "Accepted",
    "Rejected",
    "Running",
    "Main menu",
    "Dark Mode",
    "Light Mode",
    "Language",
    "Help page",
    "Instructions",
    "Editor",
    "Sample Input",
    "# About Turing Game\nTuring Game is a fun puzzle game where you are asked to design Turing machines, capable of doing a specific task like determining whether a given chess game has ended, or whether a given maze is solvable. The game was inspired by Alan Turing's work on computation theory, and was brought to life as a fun hobby project.\n\n# How to Play\nThe goal of the game is to come up with a table such as the one below, which describes how a Turing machine will operate. Once you're done, you submit your table and see whether your designed machine passed all the tests or not.",
    "The table of instructions consists of lines, each with 5 words on it. Before talking about what goes in these lines, let's talk about the machine itself.\n\n# What is a Turing Machine\nTuring machine is a hypothetical machine, which always stands on an infinite field of cells. Some of the cells might have a symbol written on them, such as \"A\", or \"2\". The Turing machine can *read* the symbol on the square it stands. It cannot read symbols on other cells; it needs to *move* onto that cell in order to read the symbol.",
    "Likewise, Turing machine can *change* the symbol underneath it. It can change, for example, an \"A\" to a \"B\", or an empty cell to a \"C\", or a \"C\" to an empty cell.",
    "Turing machine can move only in four directions at a time: to the left, to the right, upwards, and downwards. It can also be designed to stay and not move in certain conditions.",
    "To sum up, Turing machine can read, write and move. That's all it can. But what makes the Turing machine behave in a specific way? Can it behave however it would please?\n\n# The answer is: No\nIt is the table of *instructions* what decides how a Turing machine will behave. Let's analyse one of them:",
    "This instruction reads \"If the machine is in *state* A, and if the symbol underneath is 0, change the state to B. Change the 0 to 1, and move right.\"\n\n# States\nTuring machines are always in some state. This is analogous to how humans are always in an emotional state: happy, angry, sad, excited, relaxed. Humans in different states will behave differently. For example, an angry person will not talk much; an excited person will breathe faster. Likewise, Turing machines can be in state \"move right until you find a symbol A\", or in state \"move left and change every A to B\".\n\n# An Example\nLet us assume that our Turing machine has the following instructions, and is positioned in the following field:",
    "Let us also assume that our machine is currently in state A. Here is how it will work:\n\n1. It will read all the instructions in order:\n  - \"If the state is B and the symbol is 1: change the state to A; change the symbol to 2; and move right.\"\n  - \"If the state is A and the symbol is 2: change the state to B; change the symbol to 4; and move up.\"\n  - \"If the state is A and the symbol is 3: change the state to C; change the symbol to 1; and move left.\"\n\n2. Evaluate which one is applicable:\n  - The first instruction is not applicable, because machine is not in state B.\n  - The second instruction is not applicable, because symbol under the machine is not 2.\n  - Third instruction is applicable since both conditions are satisfied.\n\n3. Apply the instruction:\n  - Change the state to C.\n  - Change the symbol to 1.\n  - Move one cell to the left.\n\n4. Repeat.\n\n# An Exercise\nLet us design a machine which will move rightwards until it encounters a X, and when finds it, it will stay there.",
    "Two states are sufficient in this case:\n\n1. **Didn't find X**\n2. **Found X**\n\nNext, let's think about what should the machine do in each case:\n\n1. **Didn't find X** - Move right until you find an X.\n2. **Found X** - Stay there forever.\n\nNow, let us rephrase these:\n\n1. If the symbol underneath is not an X, move right, and keep looking.\n2. If the symbol underneath is an X, don't move anywhere, and stop looking.\n\nLet's turn to the first sentence, and try to turn it to an instruction:\n\n- This sentence only applies when machine is searching (when it is in state \"Didn't find X\"), and when the symbol underneath is not an X.\n- If we assume that the field is empty everywhere except where the X is, we can tell that this sentence only applies when the symbol under the machine is a *blank* symbol.\n- What will be the next state? Since it says \"keep looking\", we infer that the state shouldn't change.\n- What will the symbol changed to? Since there is no requirements to change the symbols, we will leave them as blank symbols.\n\nNow, we are ready to turn the sentence to a formal instruction.",
    "A few things to note:\n- We can't use spaces in formal state names, since instructions have to be of length 5 words, seperated by spaces. Thus we abbreviated \"Didn't find X\" to \"DFX\".\n- We can't represent the blank symbols as nothing, again, since the length would not be 5. The convention is to use _ meaning a blank cell.\n- The convention is to use R for \"right\", L for \"left\", U for \"up\", D for \"down\", N for \"none\".\n\nThe second sentence can be rephrased as follows:\n\n- If you were searching an X, and if there is an X underneath, you have found the X. Don't change it to anything and don't move anywhere.",
    "We are not done yet. What will happen when the machine has found the X and is now in state FX? We have no instructions dictating what to do when in state FX. Let's write one.",
    "The design looks complete! Congratulations.\n\n# Halt or not to Halt\nIn fact, the design of the Turing machine in the previous exercise is faulty. Let's see why:",
    "This machine will keep on executing the third instruction over and over once it finds the X. This behavior is called *looping* and it is often an undesired behavior. This is akin to games on a computer getting stuck. The only option in that case is to force the computer to stop the program. What we would like instead is a program that doesn't get stuck. By analogy, we would never want our Turing machine to loop; we would want it to *halt* once it's done its job.\n\nHalting is achieved in two ways:\n1. If the Turing machine converts itself to a special state called ACCEPT, it halts. When this happens, the machine is said to have \"halted and accepted\".\n2. If the Turing machine, at any instant, can't find an applicable instruction, it converts itself to another special state called REJECT, and halts. It is said to have \"halted and rejected\".\n\nPuzzles here are all called *decision problems*: Problems where a Turing machine is answering a yes/no type of questions. For example, is this number a prime number? Yes. Is this game over? No.\n\nBy convention, if the machine *accepts*, it corresponds to an answer of \"yes\". If it *rejects*, it corresponds to \"no\". If it loops? This means no answers are given, which is undesired.\n\n# Another Exercise\nThis time, we will design a machine, which tells whether a given number is even or not. By the statement, you should understand that if the number is even, Turing machine should \"accept\", if odd, then \"reject\". Let us see how the numbers will be positioned on the field:",
    "How do you check if a number is even or not? The simplest method is to examine the last digit: if it's 0, 2, 4, 6 or 8, then it is even. Otherwise, odd. So, our machine needs to traverse to the right end of the number in order to examine the last digit. How would the machine know if it is the end? If the symbol underneath is not a number, but a blank symbol, that would indicate that the last digit is on the left of the blank symbol.\n\nNow let us write down the instructions in a non-formal way:\n\n1. Start\n2. Go right until you see a blank symbol.\n3. Go one step left.\n4. If the symbol is 0, 2, 4, 6, or 8, accept.\n5. Otherwise, reject.\n\nFrom the procedure, let us write down the list of states the machine can be in:\n\n1. Didn't reach end\n2. Reached end\n3. Moved one step left\n\nAbbreviate them:\n\n1. DRE\n2. RE\n3. MOSL\n\nHere, we need to keep in our mind that the initial state is DRE. This needs to be pointed out. Now, let us write down the instructions in an almost complete form:",
    "If you look closely, you would notice that the fifth instruction is redundant: If the state is MOSL and symbol is not even, then none of these instructions would apply. Hence, the machine would go to the REJECT state by itself.\n\nAnother thing worth to point out: instructions two and three can be reduced to a single one. The state RE is redundant here. Let us see what we got:",
    "The only thing left is to replace \"number\" by numbers 0-9, and \"even\" by the even ones. Our final product becomes:",
    "Let us now test the design with the numbers 999 and 1000:",
    "# Summary\n- Turing machines need a table of instructions to function\n- Turing machines can move, read and change symbols.\n- Turing machines can change their states looking at their current state and the symbol.\n- Turing machines must either accept or reject in the end.\n- Looping is bad.\n\n# Fun Facts\n- Your phones and computers are all Turing machines: they can execute instructions. That's how we test your machine here!\n- Turing machines *define* what makes a computer a \"computer\": having a field of symbols (RAM), and being able to execute instructions (CPU).\n- Any problem that is *solvable* is solvable with a Turing machine.\n- Any programming language which claims to be able to solve all solvable problems can prove it by implementing a Turing machine simulator.\n- Such languages are called Turing-complete.\n\n\n\n# Final Words\nIf you would like to learn more about Turing machines (and friends), then find a textbook of Computation Theory, Formal Languages and Automata.\n\nIf you find a bug in this app, or if you want to contribute by translating it to a different language, head to the [official repository](https://github.com/denizbasgoren/turing) of the project, and file an issue.\n\nLater on, we plan to improve the project by adding game-like feel with graphics, so keep tuned!",
    "DFX",
    "FX",
    "DRE",
    "RE",
    "MOSL",
    "number",
    "even",
    "odd",
    "# Problem\nYou and a friend are playing the game of rock, paper and scissors. Determine if you won the game.\n\n# Symbols\nR = rock, S = scissors, P = paper, N = none.\n\n# Rules\n- Rock beats scissors\n- Scissors beat paper\n- Paper beats rock\n- All others beat the one who plays none\n- The one who plays none never wins\n\n# Format\nTuring machine initially stands on your symbol. On the right lies the symbol of your friend.",
    "# Problem\nDetermine whether the given word is a polyndrome. A word is a polyndrome if it reads the same way left-to-right and right-to-left.\n\n# Symbols\nLetters of the words are uppercase letters A-Z of the english alphabet.\n\n# Format\nTuring machine is placed on the leftmost letter of the word.",
    "# Problem\nDetermine if given tictactoe game is tied.\n\n# Symbols\nOne side plays X, other side plays O. You can assume that there are no empty cells left.\n\n# Rules\nGame is tied if none of the players have won the game. Players can win in 4 ways:\n- By filling all the rows of a column with their symbol\n- By filling all the columns of a row with their symbol\n- By filling the main diagonal ( from top-left corner to bottom-right corner )\n- By filling the cross diagonal ( from top-right corner to bottom-left corner )\n\n# Format\nThe square can be 3x3, 4x4 or higher. Turing machine is always positioned on the top-left corner.",
    "# Problem\nDetermine if you are checked in a given chess game.\n\n# Symbols\nR = castle, N = knight, B = bishop, Q = queen, K = king, P = pawn, . = empty. Uppercase letters represent white's pieces, while lowercase letters represent black's ones.\n\n# Rules\n You play as the whites.\n\n# Format\n8x8 chessboard is placed on the field as seen by whites (cell a1 is bottom-left corner). Turing machine is placed on the top-left corner.",
    "# Problem\nDetermine if the given maze is solvable. That is, its exit is reachable.\n\n# Symbols\n_ = Empty paths, O = Walls, X = Exit.\n\n# Format\nMaze is rectangular and of unknown dimensions. It has an exit on bottom-right corner, marked with X. Turing machine is placed on the top-left corner.",
    "# Problem\nSoldiers of two empires confront on the battlefield. Determine if your army has more soldiers.\n\n# Symbols\nY = your army, E = enemies army. Assume that there are no empty cells.\n\n# Format\nBattlefield is a rectangle of unknown dimensions. Turing machine is positioned on top-left corner.",
    "# Problem\nDetermine if the given Sudoku puzzle is being solved correctly.\n\n# Symbols\n1-9 digits are present. Blank cells are filled with \".\".\n\n# Rules\nClassic rules of sudoku apply:\n- Every row of the 9x9 table consists of digits 1-9, each occuring only once.\n- Every column of the 9x9 table consists of digits 1-9, each occuring only once.\n- The nine 3x3 sections consist of digits 1-9, each occuring only once.\n\n# Format\nTuring machine is placed on the top-left corner.",
    "# Problem\nDetermine if the product of two numbers is given correctly.\n\n# Symbols\nOnly 0-9 numbers are present.\n\n# Constraints\nNumbers can be at most 4 digits long. Thus, their product can be at most 7 digits long.\n\n# Format\nNumbers are all aligned to the left and stand one above the other. First two rows are of numbers to be multiplied, and the third row is of the product.",
    "# Problem\nA traveller wants to visit every country by airplanes. Determine if it is possible to visit all the countries given that airplanes don't fly from every country to every other.\n\n# Symbols\nCountry names are lowercase letters a-z of English language.\n\n# Format\nOn the field are listed air routes, one above the other. Each list item consists of two characters next to each other, representing a destination. Destinations are unordered: airplanes fly both ways.\n\nNote that there are only the countries in the world, which are mentioned on the list on the field. Don't assume that there always are 26 countries.",
    "# Problem\nDetermine if the given Turing machine accepts the given input. Assume that it always halts.\n\n# Symbols\nThe turing machine to be simulated can move only right (R) and left (L). Symbols on the tape (field) can contain _, 0 and 1 only. State names are: a (accepting state), b, c, d, e, f, g, h, i (initial state), r (rejecting state).\n\n# Format\nFirst line is the tape (field) of the one-dimential Turing machine to be simulated. It is infinite on both ends. Your Turing machine is placed on the tape, exactly where the Turing machine to be simulated is located initially.\n\nRight under the tape are listed the instructions, aligned to the left. Instructions are all 5-character-long. Their order is the same as in this application. Since all characters are of length 1, the 5 elements don't have to be seperated."
]